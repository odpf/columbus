swagger: '2.0'
info:
  title: "Universal Search"
  description: "Universal Search API"
  version: 0.0.0
host: localhost:3000
basePath: "/v1"
schemes: 
  - "http"
definitions:
  Classifications: &CLASSIFICATIONS
    type: string
    description: "defines the 'class' of the resource"
    enum:
      - resource
      - dataset
      - schema
  Record:
    type: object
    properties:
      name:
        type: string
      urn:
        type: string
      team:
        type: string
      environment:
        type: string
  Status:
    type: object
    properties:
      status:
        type: string
        default: success
  AdjacencyEntry:
    type: object
    properties:
      urn:
        type: string
      type:
        type: string
      downstreams: 
        type: array
        items:
          type: string
      upstreams:
        type: array
        items:
          type: string
  AdjacencyMap:
    type: object
    properties:
      "<NodeLabel>":
        $ref: '#/definitions/AdjacencyEntry'
  Type:
    type: object
    properties:
      name:
        type: string
        description: name of the type (for e.g. dagger, firehose)
      classification:
        <<: *CLASSIFICATIONS
      record_attributes:
        type: object
        description: defines metadata for the documents that belong to this type. All properties under record_attributes define(s) a mapping of logical purpose, to the name of the key(s) in the documents that hold those information 
        properties:
          id:
            type: string
          title:
            type: string
          description:
            type: string
          labels:
            type: array
            items:
              type: string
  Error:
    type: object
    properties:
      reason:
        type: string
        description: "error message"
  SearchResult:
    type: object
    properties:
      id:
        type: string
        description: "URN of the resource"
      title:
        type: string
        description: "describes the resource in a human readable form"
      type:
        type: string
        description: "the individual type of the resource. For example: dagger, firehose"
      description:
        type: string
        description: "optional description of the record"
      classification:
        <<: *CLASSIFICATIONS
      labels:
        type: object
        description: "key value pairs describing the labels configured for the given type of resource. Example of labels: team, created, owner etc"
  ValidationError:
    allOf:
      - $ref: '#/definitions/Error'
      - type: object
        properties:
          details:
            type: object
            description: error details. the keys are integer indices for the records that failed validation, and the value is a string describing the reason why that record fails validation
paths:
  "/lineage":
    get:
      summary: lineage list api
      description: "Returns the lineage graph, optionally filtered by type. Each entry in the graph describes a resource using it's urn and type, and has `downstreams` and `upstreams` fields that declare related resources. By default, the returned graph will only show immediate and directly related resources. For instance, say that according to the lineage configuration, there exist 3 resources R1,  R2 and R3 where data flows from R1 -> R2 -> R3. If the graph is requested with the filter for R1 and R3 , the returned Graph will have a Node R1 that references a downstream R2, but since it was filtered out, it won't be available in the graph. Similarly, R3 will declare a phamtom upstream R2. This can be addressed via the `collapse` feature. If we make the same request with collapse set to true, R1 will declare R3 as its downstream (using trasitive property) and R3 will also have a corresponding upstream declaration of R1."
      produces:
        - "application/json"
      parameters:
        - in: query
          name: filter.type
          type: string
        - in: query
          name: collapse
          type: boolean
      responses:
        200:
          description: OK
          schema:
            $ref: '#/definitions/AdjacencyMap'
        404:
          description: resource not found
          schema:
            $ref: '#/definitions/Error'
  "/lineage/{type}/{resource}":
    get:
      summary: lineage get api
      description: "Returns lineage graph of a single resource. For BQTable to BQTable lineage, set collapse to true"
      produces:
        - "application/json"
      parameters:
        - in: query
          name: collapse
          type: boolean
      responses:
        200:
          description: OK
          schema:
            $ref: '#/definitions/AdjacencyMap'
        404:
          description: invalid type requested
          schema:
            $ref: '#/definitions/Error'
  "/types":
    put:
      summary: initialise a type
      description: used for initialising/update a type. A type in columbus's nomenclature is a "collection" of documents that belong to a single named type. Type holds metadata about this collection, used when serving search requests
      produces:
        - "application/json"
      parameters:
        - in: body
          name: ""
          schema: 
            $ref: "#/definitions/Type"
      responses:
        201:
          description: OK
          schema:
            $ref: '#/definitions/Type'
        400:
          description: invalid type
          schema:
            $ref: '#/definitions/Error'
  "/types/{name}":
    put:
      summary: upload documents for a given type.
      description: Use this API for adding records for a certain type. The document can have any number of fields, however; it must atleast have fields specified by 'title' and 'id' properties on type.record_attributes. The value of these properties must be string and they must be located at the object root.
      produces:
        - "application/json"
      parameters:
        - in: path
          name: name
          type: string
          required: true
        - in: body
          name: payload
          schema:
            type: array
            items:
              $ref: '#/definitions/Record'
      responses:
        200:
          description: OK
          schema:
            $ref: '#/definitions/Status'
        400:
          description: validation error
          schema:
            $ref: '#/definitions/ValidationError'
    get:
      summary: list documents for the type
      produces:
        - "application/json"
      parameters:
        - in: path
          name: name
          type: string
          required: true
        - in: query
          name: filter.environment
          type: string
          description: environment name for filtering the records only for specific environment
        - in: query
          name: select
          type: string
          description: comma separated list of fields to return per record (only toplevel keys are supported)
      responses:
        200:
          description: OK
          schema:
            type: array
            items:
              $ref: '#/definitions/Record'
        400:
          description: bad input
          schema:
            $ref: '#/definitions/Error'
        404:
          description: not found
          schema:
            $ref: '#/definitions/Error'
  "/types/{name}/{id}":
    get:
      summary: get a record by id
      parameters:
        - in: path
          name: name
          type: string
          required: true
        - in: path
          name: id
          type: string
          required: true
      produces:
        - "application/json"
      responses:
        200:
          description: OK
          schema:
            $ref: '#/definitions/Record'
        404:
          description: document or type does not exist
          schema:
            $ref: '#/definitions/Error'
        
  "/search":
    get:
      summary: search for resources
      description: "API for querying documents. 'text' is fuzzy matched against all the available datasets, and matched results are returned. You can specify additional match criteria using 'filter.*' query parameters. You can specify each filter multiple times to specify a set of values for those filters. For instance, to specify two landscape 'vn' and 'th', the query could be `/search/?text=<text>&filter.environment=integration&filter.landscape=vn&filter.landscape=th`"
      produces:
        - "application/json"
      parameters:
        - in: query
          name: "text"
          description: "text to search for (fuzzy)"
          required: true
          type: string
        - in: query
          description: "number of results to return"
          name: "size"
          type: integer
        - in: query
          name: "filter.environment"
          type: string
          description: "restrict results to specified environment(s) eg, integrated, test, staging, production"
        - in: query
          name: "filter.landscape"
          type: string
          description: "restrict results to specified landscape(s)"
        - in: query
          name: "filter.entity"
          type: string
          description: "restrict results to specified organisation"
        - in: query
          name: "filter.type"
          type: string
          description: 'restrict results to the specified types (as in a Columbus type, for instance "dagger", or "firehose")'
      responses:
        200:
          description: OK
          schema:
            type: array
            items:
              $ref: "#/definitions/SearchResult"
        400:
          description: misconfigured request parameters
          schema:
            $ref: "#/definitions/Error"
